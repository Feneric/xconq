/* Definitions for directions of the compass.
   Copyright (C) 1987-1989, 1991-1994, 1996, 2001 Stanley T. Shebs.

Xconq is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2, or (at your option)
any later version.  See the file COPYING.  */

/*! \file kernel/dir.h
 * \brief Definitions for the directions of the compass.
 *
 * The terrain model is based on hexes arranged in horizontal rows.  This
 * means that although east and west remain intact, the concepts of north
 * and south have vanished.
 * Unfortunately, not all hex-dependent definitions are here.  Pathfinding
 * code has some knowledge of hexes also, as does map generation and
 * probably parts of the machine player code.
 */

/*! \brief Number of directions. */
#define NUMDIRS 6

/* Symbols naming the directions. */

#define NODIR -1
#define NORTHEAST 0
#define EAST  1
#define SOUTHEAST 2
#define SOUTHWEST 3
#define WEST  4
#define NORTHWEST 5

/*! \brief String names for the directions. */
#define DIRNAMES { "NE", "E", "SE", "SW", "W", "NW" }

/*! \brief Conversions from directions to x,y deltas. */
#define DIRX { 0, 1,  1,  0, -1, -1 }
#define DIRY { 1, 0, -1, -1,  0,  1 }

/*! \brief Iteration over the different directions.
 *
 * Iterate through all six directions, going from NORTHEAST to
 * NORTHWEST.
 * \param dir is the direction iteration variable.
 */
#define for_all_directions(dir) \
for ((dir) = 0; (dir) < NUMDIRS; ++(dir))

/* \brief Interate through directions from random start.
 *
 * Iteration, starting with a random direction, but going in a
 * consistent order once started.  Generate a random number between
 * 0 and 5, inclusive, the step throught the directions using a modulo 
 * count.
 * \see xrandom, NUMDIRS.
 * \param dir is the direction iteration variable.
 * \param tmp is the starting direction (generated by xrandom).
 */
#define for_all_directions_randomly(dir,tmp)  \
  for ((tmp) = 0, (dir) = xrandom(NUMDIRS); (tmp) < NUMDIRS; ++(tmp), (dir) = ((dir) + 1) % NUMDIRS)

/*! \brief Formulas for relative directions to the left.
 *
 * \param d is the direction to turn.
 */
#define left_dir(d) (((d) + 5) % NUMDIRS)

/*! \brief Formulas for relative directions to the right.
 *
 * \param d is the direction to turn.
 */
#define right_dir(d) (((d) + 1) % NUMDIRS)

/*! \brief Oposite direction.
 *
 * Formula for generating the opposite direction to the given direction.
 * \param d is the direction for which to find the opposite direction.
 */
#define opposite_dir(d) (((d) + 3) % NUMDIRS)

/*! \brief Difference in directions.
 *
 * Compute the difference between two directions, always computing
 * relative to the first direction.
 * \param d1 is the first direction.
 * \param d2 is the second direction.
 */
#define dir_subtract(d1, d2) (((d1) - (d2) + NUMDIRS) % NUMDIRS)

/*! \brief Smallest difference in directions.
 *
 * This macro looks for the smallest difference, going each way.
 * \param d1 is the first direction.
 * \param d2 is the second direction.
 */
#define angle_with(d1, d2)  \
  min(((d1) - (d2) + NUMDIRS) % NUMDIRS, ((d2) - (d1) + NUMDIRS) % NUMDIRS)

/*! \brief Generate random direction.
 *
 * Generates a random direction.
 * \see xrandom, NUMDIRS.
 */
#define random_dir() (xrandom(NUMDIRS))

/*! \brief Direction name array. */
extern const char *dirnames[];

/*! \brief X delta array. */
extern int dirx[];
/*1 \brief Y delta array. */
extern int diry[];
